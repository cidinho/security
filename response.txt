package br.com.compat;

import java.lang.reflect.Method;
import java.net.URI;
import java.util.*;

/**
 * Utilitário para converter Response entre javax <-> jakarta via reflection.
 *
 * - Os métodos retornam Object para evitar depêndencia de compile-time.
 * - Reconstrói status, entity, headers, location e cookies (quando possível).
 *
 * Uso:
 *   Object jakartaResp = ResponseCompatibility.convertToJakarta(javaxResponse);
 *   Object javaxResp = ResponseCompatibility.convertToJavax(jakartaResponse);
 */
public final class ResponseCompatibility {

    private ResponseCompatibility() {}

    // ---------- Public API ----------

    public static Object convertToJakarta(Object javaxResponse) {
        if (javaxResponse == null) return null;
        Map<String, List<Object>> headers = extractHeaders(javaxResponse);
        int status = extractStatus(javaxResponse);
        Object entity = extractEntity(javaxResponse);
        String mediaType = extractMediaTypeAsString(javaxResponse);
        String location = extractLocationAsString(javaxResponse);
        List<String> setCookieHeaders = extractSetCookieHeaders(javaxResponse);

        return buildResponseViaReflection("jakarta.ws.rs.core.Response",
                status, entity, mediaType, headers, setCookieHeaders, location);
    }

    public static Object convertToJavax(Object jakartaResponse) {
        if (jakartaResponse == null) return null;
        Map<String, List<Object>> headers = extractHeaders(jakartaResponse);
        int status = extractStatus(jakartaResponse);
        Object entity = extractEntity(jakartaResponse);
        String mediaType = extractMediaTypeAsString(jakartaResponse);
        String location = extractLocationAsString(jakartaResponse);
        List<String> setCookieHeaders = extractSetCookieHeaders(jakartaResponse);

        return buildResponseViaReflection("javax.ws.rs.core.Response",
                status, entity, mediaType, headers, setCookieHeaders, location);
    }

    // ---------- Extraction helpers (reflection) ----------

    private static int extractStatus(Object response) {
        try {
            Method m = response.getClass().getMethod("getStatus");
            Object v = m.invoke(response);
            if (v instanceof Integer) return (Integer) v;
        } catch (Exception ignored) {}
        // fallback common names
        try {
            Method m = response.getClass().getMethod("status");
            Object v = m.invoke(response);
            if (v instanceof Integer) return (Integer) v;
        } catch (Exception ignored) {}
        return 200;
    }

    private static Object extractEntity(Object response) {
        try {
            Method m = response.getClass().getMethod("getEntity");
            return m.invoke(response);
        } catch (Exception ignored) {}
        return null;
    }

    private static Map<String, List<Object>> extractHeaders(Object response) {
        Map<String, List<Object>> result = new LinkedHashMap<>();
        try {
            // try getHeaders()
            Method m = response.getClass().getMethod("getHeaders");
            Object headersObj = m.invoke(response);
            if (headersObj != null) {
                if (headersObj instanceof Map) {
                    Map<?,?> raw = (Map<?,?>) headersObj;
                    for (Map.Entry<?,?> e : raw.entrySet()) {
                        String key = String.valueOf(e.getKey());
                        Object val = e.getValue();
                        List<Object> list = new ArrayList<>();
                        if (val instanceof Collection) list.addAll((Collection<?>) val);
                        else list.add(val);
                        result.put(key, list);
                    }
                    return result;
                } else {
                    // try entrySet via reflection
                    try {
                        Method entrySet = headersObj.getClass().getMethod("entrySet");
                        Object es = entrySet.invoke(headersObj);
                        Iterable<?> it = (Iterable<?>) es;
                        for (Object e : it) {
                            Method getKey = e.getClass().getMethod("getKey");
                            Method getVal = e.getClass().getMethod("getValue");
                            String key = String.valueOf(getKey.invoke(e));
                            Object val = getVal.invoke(e);
                            List<Object> list = new ArrayList<>();
                            if (val instanceof Collection) list.addAll((Collection<?>) val);
                            else list.add(val);
                            result.put(key, list);
                        }
                        return result;
                    } catch (Exception ignored) {}
                }
            }
        } catch (Exception ignored) {}

        // fallback: try getStringHeaders()
        try {
            Method m = response.getClass().getMethod("getStringHeaders");
            Object headersObj = m.invoke(response);
            if (headersObj instanceof Map) {
                Map<?,?> raw = (Map<?,?>) headersObj;
                for (Map.Entry<?,?> e : raw.entrySet()) {
                    String key = String.valueOf(e.getKey());
                    Object val = e.getValue();
                    List<Object> list = new ArrayList<>();
                    if (val instanceof Collection) list.addAll((Collection<?>) val);
                    else list.add(val);
                    result.put(key, list);
                }
            }
        } catch (Exception ignored) {}

        return result;
    }

    private static String extractMediaTypeAsString(Object response) {
        try {
            Method m = response.getClass().getMethod("getMediaType");
            Object mt = m.invoke(response);
            if (mt != null) {
                Method toS = mt.getClass().getMethod("toString");
                Object s = toS.invoke(mt);
                return s != null ? String.valueOf(s) : null;
            }
        } catch (Exception ignored) {}
        return null;
    }

    private static String extractLocationAsString(Object response) {
        try {
            Method m = response.getClass().getMethod("getLocation");
            Object loc = m.invoke(response);
            if (loc instanceof URI) return loc.toString();
            if (loc != null) return String.valueOf(loc);
        } catch (Exception ignored) {}
        return null;
    }

    private static List<String> extractSetCookieHeaders(Object response) {
        List<String> cookies = new ArrayList<>();
        // try getCookies() -> Map<String, Cookie>
        try {
            Method m = response.getClass().getMethod("getCookies");
            Object cookiesObj = m.invoke(response);
            if (cookiesObj instanceof Map) {
                Map<?,?> raw = (Map<?,?>) cookiesObj;
                for (Map.Entry<?,?> e : raw.entrySet()) {
                    Object cookieVal = e.getValue();
                    if (cookieVal != null) {
                        try {
                            Method toString = cookieVal.getClass().getMethod("toString");
                            Object s = toString.invoke(cookieVal);
                            if (s != null) cookies.add(String.valueOf(s));
                        } catch (Exception ex) {
                            cookies.add(String.valueOf(cookieVal));
                        }
                    }
                }
            }
        } catch (Exception ignored) {}

        // fallback: check headers "Set-Cookie" in getHeaders()
        try {
            Map<String, List<Object>> headers = extractHeaders(response);
            List<Object> sc = headers.get("Set-Cookie");
            if (sc == null) sc = headers.get("set-cookie");
            if (sc != null) {
                for (Object v : sc) {
                    cookies.add(String.valueOf(v));
                }
            }
        } catch (Exception ignored) {}

        return cookies;
    }

    // ---------- Builder (reflection) ----------

    /**
     * Constrói um Response via reflection chamando:
     *   <ResponseClass>.status(int).entity(...).header(...).build()
     *
     * responseClassName: "jakarta.ws.rs.core.Response" ou "javax.ws.rs.core.Response"
     */
    private static Object buildResponseViaReflection(
            String responseClassName,
            int status,
            Object entity,
            String mediaType,
            Map<String, List<Object>> headers,
            List<String> setCookieHeaders,
            String location) {

        try {
            Class<?> respClass = Class.forName(responseClassName);
            Method statusMethod = respClass.getMethod("status", int.class);
            Object builder = statusMethod.invoke(null, status);
            if (builder == null) return null;

            Class<?> builderClass = builder.getClass();

            // set entity if available
            if (entity != null) {
                try {
                    Method ent = findMethod(builderClass, "entity", Object.class);
                    if (ent != null) ent.invoke(builder, entity);
                } catch (Exception ignored) {}
            }

            // add headers map
            if (headers != null) {
                for (Map.Entry<String, List<Object>> e : headers.entrySet()) {
                    String name = e.getKey();
                    List<Object> vals = e.getValue();
                    if (vals == null) continue;
                    for (Object v : vals) {
                        try {
                            Method headerM = findMethod(builderClass, "header", String.class, Object.class);
                            if (headerM != null) headerM.invoke(builder, name, v);
                        } catch (Exception ignored) {}
                    }
                }
            }

            // media type as Content-Type header (safer than relying on MediaType class availability)
            if (mediaType != null && !mediaType.isEmpty()) {
                try {
                    Method headerM = findMethod(builderClass, "header", String.class, Object.class);
                    if (headerM != null) headerM.invoke(builder, "Content-Type", mediaType);
                } catch (Exception ignored) {}
            }

            // location
            if (location != null) {
                try {
                    // try URI param first
                    Method locMethod = findMethod(builderClass, "location", URI.class);
                    if (locMethod != null) {
                        locMethod.invoke(builder, new URI(location));
                    } else {
                        // fallback to header "Location"
                        Method headerM = findMethod(builderClass, "header", String.class, Object.class);
                        if (headerM != null) headerM.invoke(builder, "Location", location);
                    }
                } catch (Exception ignored) {}
            }

            // set-cookie headers
            if (setCookieHeaders != null && !setCookieHeaders.isEmpty()) {
                for (String cookie : setCookieHeaders) {
                    try {
                        Method headerM = findMethod(builderClass, "header", String.class, Object.class);
                        if (headerM != null) headerM.invoke(builder, "Set-Cookie", cookie);
                    } catch (Exception ignored) {}
                }
            }

            // build
            Method buildMethod = findMethod(builderClass, "build");
            if (buildMethod == null) {
                // sometimes builder is an interface; try to find no-arg build()
                buildMethod = builderClass.getMethod("build");
            }
            return buildMethod.invoke(builder);

        } catch (ClassNotFoundException cnf) {
            throw new RuntimeException("Classe de Response não encontrada: " + responseClassName, cnf);
        } catch (RuntimeException re) {
            throw re;
        } catch (Exception ex) {
            throw new RuntimeException("Erro ao construir Response " + responseClassName, ex);
        }
    }

    // procura método com assinatura aproximada (compatibilidade com impls diferentes)
    private static Method findMethod(Class<?> cls, String name, Class<?>... params) {
        try {
            return cls.getMethod(name, params);
        } catch (NoSuchMethodException ignored) {
            // procura método com mesmo nome e compatível por tipos (polimórfico)
            for (Method m : cls.getMethods()) {
                if (!m.getName().equals(name)) continue;
                Class<?>[] p = m.getParameterTypes();
                if (params == null || params.length == 0) {
                    if (p.length == 0) return m;
                    continue;
                }
                if (p.length != params.length) continue;
                boolean ok = true;
                for (int i = 0; i < p.length; i++) {
                    // permissive check: se o parâmetro declarado aceita Object ou é o mesmo tipo
                    if (params[i] == Object.class) continue;
                    if (!p[i].isAssignableFrom(params[i])) { ok = false; break; }
                }
                if (ok) return m;
            }
            return null;
        }
    }
}
