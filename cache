@Autowired
private CacheManager cacheManager;

private static final long CACHE_EXPIRATION_TIME = TimeUnit.MINUTES.toMillis(10); // 10 minutos

public Single<String[]> getPermissionsForEndpoint(final String requestPath, final String requestMethod, String payload) {
    return Single.fromCallable(() -> getCachedPermissions(requestPath, requestMethod))
            .flatMap(cachedPermissions -> {
                if (cachedPermissions != null) {
                    return Single.just(cachedPermissions); // Retorna imediatamente se já estiver no cache
                }
                return fetchAndCachePermissions(requestPath, requestMethod, payload);
            })
            .subscribeOn(Schedulers.io()); // Garante execução assíncrona
}

private String[] getCachedPermissions(String requestPath, String requestMethod) {
    Cache cache = cacheManager.getCache("permissionsCache");
    String cacheKey = requestPath + requestMethod;

    if (cache != null) {
        // Checar se o cache expirou
        Cache.ValueWrapper valueWrapper = cache.get(cacheKey);
        if (valueWrapper != null) {
            CacheItem cachedItem = (CacheItem) valueWrapper.get();
            long currentTime = System.currentTimeMillis();
            if (cachedItem != null && currentTime - cachedItem.timestamp < CACHE_EXPIRATION_TIME) {
                return cachedItem.permissions; // Retorna as permissões se ainda não expiraram
            }
        }
    }
    return null; // Cache expirado ou não encontrado
}

private Single<String[]> fetchAndCachePermissions(String requestPath, String requestMethod, String payload) {
    return Single.fromCallable(() -> {
        Map<String, Object> response = getRoles(requestPath, requestMethod, payload);
        if (response.containsKey("roles")) {
            Object rolesObject = response.get("roles");
            if (rolesObject instanceof List) {
                List<String> rolesList = (List<String>) rolesObject;
                Log.info("Permissões necessárias para acessar o endpoint {}: {}", requestPath, rolesList);

                String[] permissions = rolesList.toArray(new String[0]);
                cachePermissions(requestPath, requestMethod, permissions);
                return permissions;
            }
        }
        return new String[0];
    });
}

private void cachePermissions(String requestPath, String requestMethod, String[] permissions) {
    Cache cache = cacheManager.getCache("permissionsCache");
    if (cache != null) {
        String cacheKey = requestPath + requestMethod;
        CacheItem cacheItem = new CacheItem(permissions, System.currentTimeMillis());
        cache.put(cacheKey, cacheItem);
    }
}

// Classe auxiliar para armazenar permissões e timestamp
public static class CacheItem {
    private String[] permissions;
    private long timestamp;

    public CacheItem(String[] permissions, long timestamp) {
        this.permissions = permissions;
        this.timestamp = timestamp;
    }
}
